#!/usr/bin/env python3
"""
SiLU LUT 65,536개를 Q6.10 포맷으로 계산하여 C 헤더에 const int16_t 배열로 출력.
- 인덱스 i (0..65535) → int16_t로 해석한 값 v (2의 보수). x = v/1024.
- SiLU(x) = x * sigmoid(x) = x / (1 + exp(-x))
- 출력 = round(SiLU(x) * 1024), int16 범위로 클램프.
FPGA 등에서 런타임 exp 없이 LUT만 참조하기 위함.
"""
import math

Q6_10_SCALE = 1024.0
SIZE = 65536

def int16_from_uint16(i):
    """인덱스 i (0..65535)를 int16_t 2의 보수로 해석."""
    i = i & 0xFFFF
    return i - 65536 if i >= 32768 else i

def main():
    lut = []
    for i in range(SIZE):
        v = int16_from_uint16(i)
        x = float(v) / Q6_10_SCALE
        if not math.isfinite(x):
            r = 32767 if x > 0 else -32768
        else:
            sig = 1.0 / (1.0 + math.exp(-x))
            silu = x * sig
            q = silu * Q6_10_SCALE
            r = int(round(q))
            if r > 32767:
                r = 32767
            elif r < -32768:
                r = -32768
        lut.append(r)

    # C 헤더 출력
    out_path = "csrc/operations/silu_lut_data.h"
    with open(out_path, "w") as f:
        f.write("/* SiLU LUT Q6.10: 65,536 entries. Generated by tools/gen_silu_lut.py. Do not edit. */\n")
        f.write("#ifndef SILU_LUT_DATA_H\n#define SILU_LUT_DATA_H\n\n")
        f.write("#include <stdint.h>\n\n")
        f.write("#define SILU_LUT_SIZE 65536\n\n")
        f.write("static const int16_t silu_lut_q610[SILU_LUT_SIZE] = {\n")
        per_line = 16
        for start in range(0, SIZE, per_line):
            chunk = lut[start : start + per_line]
            line = ", ".join(str(x) for x in chunk)
            f.write("  " + line + ",\n")
        f.write("};\n\n#endif /* SILU_LUT_DATA_H */\n")
    print(f"Wrote {out_path} ({SIZE} entries)")

if __name__ == "__main__":
    main()
